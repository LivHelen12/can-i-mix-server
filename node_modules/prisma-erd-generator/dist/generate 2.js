"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapPrismaToDb = exports.parseDatamodel = void 0;
const path = __importStar(require("path"));
const child_process = __importStar(require("child_process"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const dotenv = __importStar(require("dotenv"));
dotenv.config(); // Load the environment variables
function getDataModelFieldWithoutParsing(parsed) {
    const startOfField = parsed.indexOf('"datamodel"');
    const openingBracket = parsed.indexOf('{', startOfField);
    let numberOfOpeningBrackets = 0;
    let closingBracket = openingBracket;
    while (closingBracket < parsed.length) {
        const char = parsed[closingBracket++];
        if (char === '{') {
            numberOfOpeningBrackets++;
        }
        else if (char === '}') {
            numberOfOpeningBrackets--;
            if (numberOfOpeningBrackets === 0) {
                break;
            }
        }
    }
    return parsed.slice(openingBracket, closingBracket);
}
async function parseDatamodel(engine, model, tmpDir) {
    // Could theoretically use original file instead of re-writing the option
    // string to new file but logic for finding correct schema.prisma in
    // monorepos and containers can be tricky (see Prisma issue log) so safer
    // to rely on given content
    const tmpSchema = path.resolve(path.join(tmpDir, 'schema.prisma'));
    fs_1.default.writeFileSync(tmpSchema, model);
    const parsed = await new Promise((resolve, reject) => {
        var _a, _b;
        const process = child_process.exec(`${engine} --datamodel-path=${tmpSchema} cli dmmf`);
        let output = '';
        (_a = process.stderr) === null || _a === void 0 ? void 0 : _a.on('data', (l) => {
            if (l.includes('error:')) {
                reject(l.slice(l.indexOf('error:'), l.indexOf('\\n')));
            }
        });
        (_b = process.stdout) === null || _b === void 0 ? void 0 : _b.on('data', (d) => (output += d));
        process.on('exit', () => {
            resolve(output);
        });
    });
    return getDataModelFieldWithoutParsing(parsed);
}
exports.parseDatamodel = parseDatamodel;
function renderDml(dml, options) {
    var _a, _b;
    const { tableOnly = false, includeRelationFromFields = false } = options !== null && options !== void 0 ? options : {};
    const diagram = 'erDiagram';
    // Combine Models and Types as they are pretty similar
    const modellikes = dml.models.concat(dml.types);
    const enums = tableOnly
        ? ''
        : dml.enums
            .map((model) => `
        ${model.dbName || model.name} {
            ${model.values
            .map((value) => `${value.name || value.dbName} ${value.dbName || value.name}`)
            .join('\n')}
        }
    `)
            .join('\n\n');
    const classes = modellikes
        .map((model) => `  ${model.dbName || model.name} {
${tableOnly
        ? ''
        : model.fields
            .filter(isFieldShownInSchema(model, includeRelationFromFields))
            // the replace is a hack to make MongoDB style ID columns like _id valid for Mermaid
            .map((field) => {
            var _a, _b;
            return `    ${field.type.trimStart()} ${field.name.replace(/^_/, 'z_')} ${field.isId ||
                ((_b = (_a = model.primaryKey) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.includes(field.name))
                ? 'PK'
                : ''} ${field.isRequired ? '' : '"nullable"'}`;
        })
            .join('\n')}
    }
  `)
        .join('\n\n');
    let relationships = '';
    for (const model of modellikes) {
        for (const field of model.fields) {
            const isEnum = field.kind === 'enum';
            if (tableOnly && isEnum) {
                continue;
            }
            const relationshipName = `${isEnum ? 'enum:' : ''}${field.name}`;
            const thisSide = model.dbName || model.name;
            const otherSide = field.type;
            // normal relations
            if ((field.relationFromFields &&
                field.relationFromFields.length > 0) ||
                isEnum) {
                let thisSideMultiplicity = '||';
                if (field.isList) {
                    thisSideMultiplicity = '}o';
                }
                else if (!field.isRequired) {
                    thisSideMultiplicity = '|o';
                }
                const otherModel = modellikes.find((model) => model.name === otherSide);
                const otherField = otherModel === null || otherModel === void 0 ? void 0 : otherModel.fields.find(({ relationName }) => relationName === field.relationName);
                let otherSideMultiplicity = thisSideMultiplicity;
                if (otherField === null || otherField === void 0 ? void 0 : otherField.isList) {
                    thisSideMultiplicity = 'o{';
                }
                else if (!(otherField === null || otherField === void 0 ? void 0 : otherField.isRequired)) {
                    thisSideMultiplicity = 'o|';
                }
                relationships += `    ${thisSide} ${thisSideMultiplicity}--${otherSideMultiplicity} ${(otherModel === null || otherModel === void 0 ? void 0 : otherModel.dbName) || otherSide} : "${relationshipName}"\n`;
            }
            // many to many
            else if (modellikes.find((m) => m.name === field.type || m.dbName === field.type) &&
                ((_a = field.relationFromFields) === null || _a === void 0 ? void 0 : _a.length) === 0 &&
                ((_b = field.relationToFields) === null || _b === void 0 ? void 0 : _b.length)) {
                relationships += `    ${thisSide} o{--}o ${otherSide} : ""\n`;
            }
            // composite types
            else if (field.kind == 'object') {
                const otherSideCompositeType = dml.types.find((model) => model.name === otherSide);
                if (otherSideCompositeType) {
                    // most logic here is a copy/paste from the normal relation logic
                    // TODO extract and reuse
                    let thisSideMultiplicity = '||';
                    if (field.isList) {
                        thisSideMultiplicity = '}o';
                    }
                    else if (!field.isRequired) {
                        thisSideMultiplicity = '|o';
                    }
                    const otherField = otherSideCompositeType === null || otherSideCompositeType === void 0 ? void 0 : otherSideCompositeType.fields.find(({ relationName }) => relationName === field.relationName);
                    let otherSideMultiplicity = thisSideMultiplicity;
                    if (otherField === null || otherField === void 0 ? void 0 : otherField.isList) {
                        thisSideMultiplicity = 'o{';
                    }
                    else if (!(otherField === null || otherField === void 0 ? void 0 : otherField.isRequired)) {
                        thisSideMultiplicity = 'o|';
                    }
                    relationships += `    ${thisSide} ${thisSideMultiplicity}--${otherSideMultiplicity} ${otherSideCompositeType.dbName || otherSide} : "${relationshipName}"\n`;
                }
            }
        }
    }
    return diagram + '\n' + enums + '\n' + classes + '\n' + relationships;
}
const isFieldShownInSchema = (model, includeRelationFromFields) => (field) => {
    if (includeRelationFromFields) {
        return field.kind !== 'object';
    }
    return (field.kind !== 'object' &&
        !model.fields.find(({ relationFromFields }) => relationFromFields &&
            relationFromFields.includes(field.name)));
};
const mapPrismaToDb = (dmlModels, dataModel) => {
    const splitDataModel = dataModel === null || dataModel === void 0 ? void 0 : dataModel.split('\n').filter((line) => line.includes('@map') || line.includes('model ')).map((line) => line.trim());
    return dmlModels.map((model) => {
        return {
            ...model,
            fields: model.fields.map((field) => {
                let filterStatus = 'None';
                // get line with field to \n
                const lineInDataModel = splitDataModel
                    // filter the current model
                    .filter((line) => {
                    if (filterStatus === 'Match' &&
                        line.includes('model ')) {
                        filterStatus = 'End';
                    }
                    if (filterStatus === 'None' &&
                        line.includes(`model ${model.name} `)) {
                        filterStatus = 'Match';
                    }
                    return filterStatus === 'Match';
                })
                    .find((line) => line.includes(`${field.name} `) &&
                    line.includes('@map'));
                if (lineInDataModel) {
                    const regex = new RegExp(/@map\(\"(.*?)\"\)/, 'g');
                    const match = regex.exec(lineInDataModel);
                    if (match === null || match === void 0 ? void 0 : match[1]) {
                        const name = match[1]
                            .replace(/^_/, 'z_') // replace leading underscores
                            .replace(/\s/g, ''); // remove spaces
                        field = {
                            ...field,
                            name: name,
                        };
                    }
                }
                return field;
            }),
        };
    });
};
exports.mapPrismaToDb = mapPrismaToDb;
exports.default = async (options) => {
    var _a, _b, _c, _d;
    try {
        const output = ((_a = options.generator.output) === null || _a === void 0 ? void 0 : _a.value) || './prisma/ERD.svg';
        const config = options.generator.config;
        const theme = config.theme || 'forest';
        const tableOnly = config.tableOnly === 'true';
        const includeRelationFromFields = config.includeRelationFromFields === 'true';
        const disabled = Boolean(process.env.DISABLE_ERD);
        const debug = config.erdDebug === 'true' || Boolean(process.env.ERD_DEBUG);
        if (disabled) {
            return console.log('ERD generator is disabled');
        }
        if (!((_b = options.binaryPaths) === null || _b === void 0 ? void 0 : _b.queryEngine))
            throw new Error('no query engine found');
        const queryEngine = (_c = options.binaryPaths) === null || _c === void 0 ? void 0 : _c.queryEngine[Object.keys((_d = options.binaryPaths) === null || _d === void 0 ? void 0 : _d.queryEngine)[0]];
        const tmpDir = fs_1.default.mkdtempSync(os_1.default.tmpdir() + path.sep + 'prisma-erd-');
        const datamodelString = await parseDatamodel(queryEngine, options.datamodel, tmpDir);
        if (!datamodelString) {
            throw new Error('could not parse datamodel');
        }
        if (debug && datamodelString) {
            fs_1.default.mkdirSync(path.resolve('prisma/debug'), { recursive: true });
            const dataModelFile = path.resolve('prisma/debug/1-datamodel.json');
            fs_1.default.writeFileSync(dataModelFile, datamodelString);
            console.log(`data model written to ${dataModelFile}`);
        }
        let dml = JSON.parse(datamodelString);
        // updating dml to map to db table and column names (@map && @@map)
        dml.models = (0, exports.mapPrismaToDb)(dml.models, options.datamodel);
        // default types to empty array
        if (!dml.types) {
            dml.types = [];
        }
        if (debug && dml.models) {
            const mapAppliedFile = path.resolve('prisma/debug/2-datamodel-map-applied.json');
            fs_1.default.writeFileSync(mapAppliedFile, JSON.stringify(dml, null, 2));
            console.log(`applied @map to fields written to ${mapAppliedFile}`);
        }
        const mermaid = renderDml(dml, {
            tableOnly,
            includeRelationFromFields,
        });
        if (debug && mermaid) {
            const mermaidFile = path.resolve('prisma/debug/3-mermaid.mmd');
            fs_1.default.writeFileSync(mermaidFile, mermaid);
            console.log(`mermaid written to ${mermaidFile}`);
        }
        if (!mermaid)
            throw new Error('failed to construct mermaid instance from dml');
        if (output.endsWith('.md'))
            return fs_1.default.writeFileSync(output, '```mermaid' + `\n` + mermaid + '```' + `\n`);
        const tempMermaidFile = path.resolve(path.join(tmpDir, 'prisma.mmd'));
        fs_1.default.writeFileSync(tempMermaidFile, mermaid);
        const tempConfigFile = path.resolve(path.join(tmpDir, 'config.json'));
        fs_1.default.writeFileSync(tempConfigFile, JSON.stringify({ deterministicIds: true, maxTextSize: 90000 }));
        let mermaidCliNodePath = path.resolve(path.join('node_modules', '.bin', 'mmdc'));
        if (!fs_1.default.existsSync(mermaidCliNodePath)) {
            const findMermaidCli = child_process
                .execSync('find ../.. -name mmdc')
                .toString()
                .split('\n')
                .filter((path) => path)
                .pop();
            if (!findMermaidCli || !fs_1.default.existsSync(findMermaidCli)) {
                throw new Error(`Expected mermaid CLI at \n${mermaidCliNodePath}\n\nor\n${findMermaidCli}\n but this package was not found.`);
            }
            else {
                mermaidCliNodePath = findMermaidCli;
            }
        }
        const mermaidCommand = `${mermaidCliNodePath} -i ${tempMermaidFile} -o ${output} -t ${theme} -c ${tempConfigFile}`;
        if (debug && mermaidCommand)
            console.log('mermaid command: ', mermaidCommand);
        child_process.execSync(mermaidCommand, {
            stdio: 'ignore',
        });
        // throw error if file was not created
        if (!fs_1.default.existsSync(output)) {
            throw new Error(`Issue generating ER Diagram. Expected ${output} to be created`);
        }
    }
    catch (error) {
        console.error(error);
        throw error;
    }
};
